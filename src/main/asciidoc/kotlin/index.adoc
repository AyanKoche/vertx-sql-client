= Reactive Postgres Client

== Usage

To use the Reactive Postgres Client add the following dependency to the _dependencies_ section of your build descriptor:

* Maven (in your `pom.xml`):

[source,xml,subs="+attributes"]
----
<dependency>
  <groupId>com.julienviet</groupId>
  <artifactId>reactive-pg-client</artifactId>
  <version>0.3.1-SNAPSHOT</version>
</dependency>
----

* Gradle (in your `build.gradle` file):

[source,groovy,subs="+attributes"]
----
dependencies {
  compile 'com.julienviet:reactive-pg-client:0.3.1-SNAPSHOT'
}
----

== Getting started

Here is the simplest way to connect, query and disconnect

[source,kotlin]
----

// Pool options
var options = PgPoolOptions(
  port = 5432,
  host = "the-host",
  database = "the-db",
  username = "user",
  password = "secret",
  maxSize = 5)

// Create the pool
var pool = PgPool.pool(options)

// A simple query
pool.query("SELECT * FROM users WHERE id='julien'", { ar ->
  if (ar.succeeded()) {
    var result = ar.result()
    println("Got ${result.size()} results ")
  } else {
    println("Failure: ${ar.cause().getMessage()}")
  }

  // Close now the pool
  pool.close()
})

----

== Connecting to Postgres

Most of the time you will use a pool to connect to Postgres:

[source,kotlin]
----

// Pool options
var options = PgPoolOptions(
  port = 5432,
  host = "the-host",
  database = "the-db",
  username = "user",
  password = "secret",
  maxSize = 5)

// Create the pool
var pool = PgPool.pool(options)

----

If you are running with Vert.x you can pass it your Vertx instance:

[source,kotlin]
----

// Pool options
var options = PgPoolOptions(
  port = 5432,
  host = "the-host",
  database = "the-db",
  username = "user",
  password = "secret",
  maxSize = 5)

// Create the pool
var pool = PgPool.pool(vertx, options)

----

You need to release the pool when you don't need it anymore:

[source,kotlin]
----

// Close the pool and all the associated resources
pool.close()

----

You can also connect directly to Postgres without a pool

[source,kotlin]
----

// Pool options
var options = PgConnectOptions(
  port = 5432,
  host = "the-host",
  database = "the-db",
  username = "user",
  password = "secret")

// Close the pool and all the associated resources
PgConnection.connect(vertx, options, { res ->
  if (res.succeeded()) {

    println("Connected")

    // Obtain our connection
    var conn = res.result()
  } else {
    println("Could not connect: ${res.cause().getMessage()}")
  }
})

----

== Running queries

When you don't need a transaction or run single queries, you can run queries directly on the pool; the pool
will use one of its connection to run the query and return the result to you.

Here is how to run simple queries:

[source,kotlin]
----
pool.query("SELECT * FROM users WHERE id='julien'", { ar ->
  if (ar.succeeded()) {
    var result = ar.result()
    println("Got ${result.size()} results ")
  } else {
    println("Failure: ${ar.cause().getMessage()}")
  }
})

----

You can do the same with prepared queries:

[source,kotlin]
----
pool.preparedQuery("SELECT * FROM users WHERE id=\$$1", Tuple.of("julien"), { ar ->
  if (ar.succeeded()) {
    var result = ar.result()
    println("Got ${result.size()} results ")
  } else {
    println("Failure: ${ar.cause().getMessage()}")
  }
})

----

Query methods return a `link:../../apidocs/com/julienviet/pgclient/PgResult.html[PgResult]` instance that works for _select_ statements

[source,kotlin]
----
pool.preparedQuery("SELECT first_name, last_name FROM users", { ar ->
  if (ar.succeeded()) {
    var result = ar.result()
    for (row in result) {
      println("User ${row.getString(0)} ${row.getString(1)}")
    }
  } else {
    println("Failure: ${ar.cause().getMessage()}")
  }
})

----

or _update_/_insert_ statements:

[source,kotlin]
----
pool.preparedQuery("\"INSERT INTO users (first_name, last_name) VALUES (\$$1, \$$2)", Tuple.of("Julien", "Viet"), { ar ->
  if (ar.succeeded()) {
    var result = ar.result()
    println(result.updatedCount())
  } else {
    println("Failure: ${ar.cause().getMessage()}")
  }
})

----

The `link:../../apidocs/com/julienviet/pgclient/Row.html[Row]` gives you access to your data by index

[source,kotlin]
----
println("User ${row.getString(0)} ${row.getString(1)}")

----

or by name

[source,kotlin]
----
println("User ${row.getString("first_name")} ${row.getString("last_name")}")

----

You can access a wide variety of of types

[source,kotlin]
----

var firstName = row.getString("first_name")
var male = row.getBoolean("male")
var age = row.getInteger("age")

// ...


----

== Using transactions

You can execute transaction using SQL `BEGIN`/`COMMIT`/`ROLLBACK`, if you do so you must use
a `link:../../apidocs/com/julienviet/pgclient/PgConnection.html[PgConnection]` and manage it yourself.

Or you can use the transaction API of `link:../../apidocs/com/julienviet/pgclient/PgConnection.html[PgConnection]`:

[source,kotlin]
----
pool.connect({ res ->
  if (res.succeeded()) {

    // Transaction must use a connection
    var conn = res.result()

    // Begin the transaction
    var tx = conn.begin().abortHandler({ v ->
      println("Transaction failed => rollbacked")
    })

    conn.query("INSERT INTO Users (first_name,last_name) VALUES ('Julien','Viet')", { ar ->
      // Works fine of course
    })
    conn.query("INSERT INTO Users (first_name,last_name) VALUES ('Julien','Viet')", { ar ->
      // Fails and triggers transaction aborts
    })

    // Attempt to commit the transaction
    tx.commit({ ar ->
      // But transaction abortion fails it
    })
  }
})

----

When Postgres reports the current transaction is failed (e.g the infamous _current transaction is aborted, commands ignored until
end of transaction block_), the transaction is rollbacked and the `link:../../apidocs/com/julienviet/pgclient/PgTransaction.html#abortHandler-io.vertx.core.Handler-[abortHandler]`
is called:

[source,kotlin]
----
pool.connect({ res ->
  if (res.succeeded()) {

    // Transaction must use a connection
    var conn = res.result()

    // Begin the transaction
    var tx = conn.begin().abortHandler({ v ->
      println("Transaction failed => rollbacked")
    })

    conn.query("INSERT INTO Users (first_name,last_name) VALUES ('Julien','Viet')", { ar ->
      // Works fine of course
    })
    conn.query("INSERT INTO Users (first_name,last_name) VALUES ('Julien','Viet')", { ar ->
      // Fails and triggers transaction aborts
    })

    // Attempt to commit the transaction
    tx.commit({ ar ->
      // But transaction abortion fails it
    })
  }
})

----

OLD DOC:


== Connecting to a database

You can use the client to connect to the database and interact with it.

[source,kotlin]
----

// Create options
var options = PgConnectOptions(
  port = 5432,
  host = "the-host",
  database = "the-db",
  username = "user",
  password = "secret")

// Connect
PgConnection.connect(vertx, options, { res ->
  if (res.succeeded()) {

    // Connected
    var conn = res.result()

    conn.createQuery("SELECT * FROM USERS").execute({ ar ->

      if (ar.succeeded()) {

        // Use result
        var result = ar.result()
      } else {
        println("It failed")
      }

      // Close the connection
      conn.close()
    })
  } else {
    println("Could not connect ${res.cause()}")
  }
})

----

You can create a pool of connection to obtain a connection instead:

[source,kotlin]
----

var options = PgPoolOptions(
  port = 5432,
  host = "the-host",
  database = "the-db",
  username = "user",
  password = "secret",
  maxSize = 20)

// Create a pool with 20 connections max
var pool = PgPool.pool(vertx, options)

pool.connect({ res ->
  if (res.succeeded()) {

    // Obtained a connection
    var conn = res.result()

    conn.createQuery("SELECT * FROM USERS").execute({ ar ->

      if (ar.succeeded()) {

        // Use result set
        var result = ar.result()
      } else {
        println("It failed")
      }

      // Return the connection to the pool
      conn.close()
    })
  } else {
    println("Could not obtain a connection ${res.cause()}")
  }
})

----

When you are done with the pool, you should close it:

[source,kotlin]
----

// Close the pool and the connection it maintains
pool.close()

----

== Prepared statements

Prepared statements can be created and managed by the application.

The `sql` string can refer to parameters by position, using $1, $2, etc...

[source,kotlin]
----
conn.prepare("SELECT * FROM USERS WHERE user_id=\$$1", { ar1 ->

  if (ar1.succeeded()) {
    var preparedStatement = ar1.result()

    // Create a query : bind parameters
    var query = preparedStatement.createQuery(Tuple.of("julien"))

    // Execute query
    query.execute({ ar2 ->
      if (ar2.succeeded()) {

        // Get result
        var result = ar2.result()
      } else {
        println("Query failed ${ar2.cause()}")
      }
    })
  } else {
    println("Could not prepare statement ${ar1.cause()}")
  }
})

----

When you are done with the prepared statement, you should close it:

[source,kotlin]
----
preparedStatement.close()

----

NOTE: when you close the connection, you don't need to close its prepared statements

By default the query will fetch all results, you can override this and define a maximum fetch size.

[source,kotlin]
----
conn.prepare("SELECT * FROM USERS", { ar1 ->
  if (ar1.succeeded()) {

    var preparedStatement = ar1.result()

    // Create a query : bind parameters
    var query = preparedStatement.createQuery().fetch(100)

    query.execute({ ar2 ->

      if (ar2.succeeded()) {
        println("Got at most 100 rows")

        if (query.hasMore()) {
          // Get results
          var result = ar2.result()

          println("Get next 100")
          query.execute({ ar3 ->
            // Continue...
          })
        } else {
          // We are done
        }
      } else {
        println("Query failed ${ar2.cause()}")
      }
    })
  } else {
    println("Could not prepare statement ${ar1.cause()}")
  }
})

----

When a query is not completed you can call `link:../../apidocs/com/julienviet/pgclient/PgQuery.html#close--[close]` to release
the query result in progress:

[source,kotlin]
----
conn.prepare("SELECT * FROM USERS", { ar1 ->

  if (ar1.succeeded()) {
    var preparedStatement = ar1.result()

    // Create a query : bind parameters
    var query = preparedStatement.createQuery()

    // Get at most 100 rows
    query.fetch(100)

    // Execute query
    query.execute({ res ->
      if (res.succeeded()) {

        // Get result
        var result = res.result()

        // Close the query
        query.close()
      } else {
        println("Query failed ${res.cause()}")
      }
    })
  } else {
    println("Could not prepare statement ${ar1.cause()}")
  }
})

----

Prepared statements can also be used for update operations

[source,kotlin]
----

// Prepare (when not cached)
// Execute
conn.preparedQuery("UPDATE USERS SET name=\$$1 WHERE id=\$$2", Tuple.of(2, "EMAD ALBLUESHI"), { ar ->

  if (ar.succeeded()) {
    // Process results
    var result = ar.result()
  } else {
    println("Update failed ${ar.cause()}")
  }
})

----


Prepared statements can also be used to createBatch operations in a very efficient manner:

[source,kotlin]
----
conn.prepare("INSERT INTO USERS (id, name) VALUES (\$$1, \$$2)", { ar1 ->
  if (ar1.succeeded()) {
    var preparedStatement = ar1.result()

    // Create a query : bind parameters
    var batch = preparedStatement.createBatch()

    // Add commands to the createBatch
    batch.add(Tuple.of("julien", "Julien Viet"))
    batch.add(Tuple.of("emad", "Emad Alblueshi"))

    batch.execute({ res ->
      if (res.succeeded()) {

        // Process results
        var results = res.result()
      } else {
        println("Batch failed ${res.cause()}")
      }
    })
  } else {
    println("Could not prepare statement ${ar1.cause()}")
  }
})

----

== Using SSL/TLS

To configure the client to use SSL connection, you can configure the `link:../../apidocs/com/julienviet/pgclient/PgConnectOptions.html[PgConnectOptions]`
like a Vert.x `NetClient`.

[source,kotlin]
----

var options = PgConnectOptions(
  port = 5432,
  host = "the-host",
  database = "the-db",
  username = "user",
  password = "secret",
  ssl = true,
  pemTrustOptions = PemTrustOptions(
    certPaths = listOf("/path/to/cert.pem")))

PgConnection.connect(vertx, options, { res ->
  if (res.succeeded()) {
    // Connected with SSL
  } else {
    println("Could not connect ${res.cause()}")
  }
})

----

More information can be found in the http://vertx.io/docs/vertx-core/java/#ssl[Vert.x documentation].

== Using a proxy

You can also configure the client to use an HTTP/1.x CONNECT, SOCKS4a or SOCKS5 proxy.

More information can be found in the http://vertx.io/docs/vertx-core/java/#_using_a_proxy_for_client_connections[Vert.x documentation].