= Reactive Postgres Client

== Usage

To use the Reactive Postgres Client add the following dependency to the _dependencies_ section of your build descriptor:

* Maven (in your `pom.xml`):

[source,xml,subs="+attributes"]
----
<dependency>
  <groupId>com.julienviet</groupId>
  <artifactId>reactive-pg-client</artifactId>
  <version>0.3.1-SNAPSHOT</version>
</dependency>
----

* Gradle (in your `build.gradle` file):

[source,groovy,subs="+attributes"]
----
dependencies {
  compile 'com.julienviet:reactive-pg-client:0.3.1-SNAPSHOT'
}
----

== Getting started

Here is the simplest way to connect, query and disconnect

[source,java]
----
PgPoolOptions options = new PgPoolOptions()
  .setPort(5432)
  .setHost("the-host")
  .setDatabase("the-db")
  .setUsername("user")
  .setPassword("secret")
  .setMaxSize(5);

// Create the pool
PgPool pool = PgPool.pool(options);

// A simple query
pool.query("SELECT * FROM users WHERE id='julien'", ar -> {
  if (ar.succeeded()) {
    PgResult<Row> result = ar.result();
    System.out.println("Got " + result.size() + " results ");
  } else {
    System.out.println("Failure: " + ar.cause().getMessage());
  }

  // Close now the pool
  pool.close();
});
----

== Connecting to Postgres

Most of the time you will use a pool to connect to Postgres:

[source,java]
----
PgPoolOptions options = new PgPoolOptions()
  .setPort(5432)
  .setHost("the-host")
  .setDatabase("the-db")
  .setUsername("user")
  .setPassword("secret")
  .setMaxSize(5);

// Create the pool
PgPool pool = PgPool.pool(options);
----

If you are running with Vert.x you can pass it your Vertx instance:

[source,java]
----
PgPoolOptions options = new PgPoolOptions()
  .setPort(5432)
  .setHost("the-host")
  .setDatabase("the-db")
  .setUsername("user")
  .setPassword("secret")
  .setMaxSize(5);

// Create the pool
PgPool pool = PgPool.pool(vertx, options);
----

You need to release the pool when you don't need it anymore:

[source,java]
----
pool.close();
----

You can also connect directly to Postgres without a pool

[source,java]
----
PgConnectOptions options = new PgConnectOptions()
  .setPort(5432)
  .setHost("the-host")
  .setDatabase("the-db")
  .setUsername("user")
  .setPassword("secret");

// Close the pool and all the associated resources
PgConnection.connect(vertx, options, res -> {
  if (res.succeeded()) {

    System.out.println("Connected");

    // Obtain our connection
    PgConnection conn = res.result();
  } else {
    System.out.println("Could not connect: " + res.cause().getMessage());
  }
});
----

== Running queries

When you don't need a transaction or run single queries, you can run queries directly on the pool; the pool
will use one of its connection to run the query and return the result to you:

[source,java]
----
pool.query("SELECT * FROM users WHERE id='julien'", ar -> {
  if (ar.succeeded()) {
    PgResult<Row> result = ar.result();
    System.out.println("Got " + result.size() + " results ");
  } else {
    System.out.println("Failure: " + ar.cause().getMessage());
  }
});
----

You can do the same with prepared statements:

[source,java]
----
pool.preparedQuery("SELECT * FROM users WHERE id=$1", Tuple.of("julien"),  ar -> {
  if (ar.succeeded()) {
    PgResult<Row> result = ar.result();
    System.out.println("Got " + result.size() + " results ");
  } else {
    System.out.println("Failure: " + ar.cause().getMessage());
  }
});
----

Query methods returns a `link:../../apidocs/com/julienviet/pgclient/PgResult.html[PgResult]` instance that works for _select_ statements

[source,java]
----
pool.preparedQuery("SELECT first_name, last_name FROM users", ar -> {
  if (ar.succeeded()) {
    PgResult<Row> result = ar.result();
    for (Row row : result) {

      // You can access columns by position
      System.out.println("User " + row.getString(0) + " " + row.getString(1));

      // Or by name
      System.out.println("User " + row.getString("first_name") + " " + row.getString("last_name"));
    }
  } else {
    System.out.println("Failure: " + ar.cause().getMessage());
  }
});
----

or _update_/_insert_ statements:

[source,java]
----
pool.preparedQuery("\"INSERT INTO users (first_name, last_name) VALUES ($1, $2)", Tuple.of("Julien", "Viet"),  ar -> {
  if (ar.succeeded()) {
    PgResult<Row> result = ar.result();
    System.out.println(result.updatedCount());
  } else {
    System.out.println("Failure: " + ar.cause().getMessage());
  }
});
----





OLD DOC:


== Connecting to a database

You can use the client to connect to the database and interact with it.

[source,java]
----
PgConnectOptions options = new PgConnectOptions()
  .setPort(5432)
  .setHost("the-host")
  .setDatabase("the-db")
  .setUsername("user")
  .setPassword("secret");

// Connect
PgConnection.connect(vertx, options, res -> {
  if (res.succeeded()) {

    // Connected
    PgConnection conn = res.result();

    conn.createQuery("SELECT * FROM USERS").execute(ar -> {

      if (ar.succeeded()) {

        // Use result
        PgResult<Row> result = ar.result();
      } else {
        System.out.println("It failed");
      }

      // Close the connection
      conn.close();
    });
  } else {
    System.out.println("Could not connect " + res.cause());
  }
});
----

You can create a pool of connection to obtain a connection instead:

[source,java]
----
PgPoolOptions options = new PgPoolOptions()
  .setPort(5432)
  .setHost("the-host")
  .setDatabase("the-db")
  .setUsername("user")
  .setPassword("secret")
  .setMaxSize(20);

// Create a pool with 20 connections max
PgPool pool = PgPool.pool(vertx, options);

pool.connect(res -> {
  if (res.succeeded()) {

    // Obtained a connection
    PgConnection conn = res.result();

    conn.createQuery("SELECT * FROM USERS").execute(ar -> {

      if (ar.succeeded()) {

        // Use result set
        PgResult<Row> result = ar.result();
      } else {
        System.out.println("It failed");
      }

      // Return the connection to the pool
      conn.close();
    });
  } else {
    System.out.println("Could not obtain a connection " + res.cause());
  }
});
----

When you are done with the pool, you should close it:

[source,java]
----
pool.close();
----

== Prepared statements

Prepared statements can be created and managed by the application.

The `sql` string can refer to parameters by position, using $1, $2, etc...

[source,java]
----
conn.prepare("SELECT * FROM USERS WHERE user_id=$1", ar1 -> {

  if (ar1.succeeded()) {
    PgPreparedStatement preparedStatement = ar1.result();

    // Create a query : bind parameters
    PgQuery query = preparedStatement.createQuery(Tuple.of("julien"));

    // Execute query
    query.execute(ar2 -> {
      if (ar2.succeeded()) {

        // Get result
        PgResult<Row> result = ar2.result();
      } else {
        System.out.println("Query failed " + ar2.cause());
      }
    });
  } else {
    System.out.println("Could not prepare statement " + ar1.cause());
  }
});
----

When you are done with the prepared statement, you should close it:

[source,java]
----
preparedStatement.close();
----

NOTE: when you close the connection, you don't need to close its prepared statements

By default the query will fetch all results, you can override this and define a maximum fetch size.

[source,java]
----
conn.prepare("SELECT * FROM USERS", ar1 -> {
  if (ar1.succeeded()) {

    PgPreparedStatement preparedStatement = ar1.result();

    // Create a query : bind parameters
    PgQuery query = preparedStatement.createQuery()
      .fetch(100); // Get at most 100 rows at a time

    query.execute(ar2 -> {

      if (ar2.succeeded()) {
        System.out.println("Got at most 100 rows");

        if (query.hasMore()) {
          // Get results
          PgResult<Row> result = ar2.result();

          System.out.println("Get next 100");
          query.execute(ar3 -> {
            // Continue...
          });
        } else {
          // We are done
        }
      } else {
        System.out.println("Query failed " + ar2.cause());
      }
    });
  } else {
    System.out.println("Could not prepare statement " + ar1.cause());
  }
});
----

When a query is not completed you can call `link:../../apidocs/com/julienviet/pgclient/PgQuery.html#close--[close]` to release
the query result in progress:

[source,java]
----
conn.prepare("SELECT * FROM USERS", ar1 -> {

  if (ar1.succeeded()) {
    PgPreparedStatement preparedStatement = ar1.result();

    // Create a query : bind parameters
    PgQuery query = preparedStatement.createQuery();

    // Get at most 100 rows
    query.fetch(100);

    // Execute query
    query.execute(res -> {
      if (res.succeeded()) {

        // Get result
        PgResult<Row> result = res.result();

        // Close the query
        query.close();
      } else {
        System.out.println("Query failed " + res.cause());
      }
    });
  } else {
    System.out.println("Could not prepare statement " + ar1.cause());
  }
});
----

Prepared statements can also be used for update operations

[source,java]
----
conn.preparedQuery("UPDATE USERS SET name=$1 WHERE id=$2", Tuple.of(2, "EMAD ALBLUESHI"), ar -> {

  if(ar.succeeded()) {
    // Process results
    PgResult<Row> result = ar.result();
  } else {
    System.out.println("Update failed " + ar.cause());
  }
});
----


Prepared statements can also be used to createBatch operations in a very efficient manner:

[source,java]
----
conn.prepare("INSERT INTO USERS (id, name) VALUES ($1, $2)", ar1 -> {
  if (ar1.succeeded()) {
    PgPreparedStatement preparedStatement = ar1.result();

    // Create a query : bind parameters
    PgBatch batch = preparedStatement.createBatch();

    // Add commands to the createBatch
    batch.add(Tuple.of("julien", "Julien Viet"));
    batch.add(Tuple.of("emad", "Emad Alblueshi"));

    batch.execute(res -> {
      if (res.succeeded()) {

        // Process results
        PgBatchResult<Row> results = res.result();
      } else {
        System.out.println("Batch failed " + res.cause());
      }
    });
  } else {
    System.out.println("Could not prepare statement " + ar1.cause());
  }
});
----

== Using SSL/TLS

To configure the client to use SSL connection, you can configure the `link:../../apidocs/com/julienviet/pgclient/PgConnectOptions.html[PgConnectOptions]`
like a Vert.x `NetClient`.

[source,java]
----
PgConnectOptions options = new PgConnectOptions()
  .setPort(5432)
  .setHost("the-host")
  .setDatabase("the-db")
  .setUsername("user")
  .setPassword("secret")
  .setSsl(true)
  .setPemTrustOptions(new PemTrustOptions().addCertPath("/path/to/cert.pem"));

PgConnection.connect(vertx, options, res -> {
  if (res.succeeded()) {
    // Connected with SSL
  } else {
    System.out.println("Could not connect " + res.cause());
  }
});
----

More information can be found in the http://vertx.io/docs/vertx-core/java/#ssl[Vert.x documentation].

== Using a proxy

You can also configure the client to use an HTTP/1.x CONNECT, SOCKS4a or SOCKS5 proxy.

More information can be found in the http://vertx.io/docs/vertx-core/java/#_using_a_proxy_for_client_connections[Vert.x documentation].